var https = require('https')
var extend = require('util')._extend
var utils = require('./lib/utils')
var nodeUtil = require('util')
var EventEmitter = require('events').EventEmitter

function Pusher(account_id, key, options) {
  EventEmitter.call(this)

  options = options || {}

  // Setup request the url and key.
  this.request_defaults = {
    hostname: 'insights-collector.newrelic.com',
    path: '/v1/accounts/' + account_id + '/events',
    headers: {
      'X-Insert-Key': key,
      'Content-Type': 'application/json'
    },
    method: 'POST'
  }

  // Default to pushing once a minute
  this.interval = (options.interval || 60) * 1000

  // API Hard limit to 1000 events per push
  this.max_events = options.max_events || 1000

  // Suggested minimum number of events due to Insights request processing
  // overhead.
  this.min_events = options.min_events || 50

  if (options.harvester === false) {
    this._harvester_enabled = false
  } else {
    this._harvester_enabled = true
  }

  this._events = []
  this._oldest_timestamp = utils.unix_now()
  this._harvester = this._start_harvester()
}
nodeUtil.inherits(Pusher, EventEmitter)

Pusher.prototype.addEvent = function(event_name, event_data) {
  var event = extend({
    eventType: event_name
  }, event_data)

  // If they didn't set a timestamp, set it ourselves so we don't lose exactly
  // when an event happened.
  if (!event.timestamp) {
    event.timestamp = utils.unix_now()
  } else if (event.timestamp < (utils.unix_now()-utils.day_in_secs + this.interval)) {
    this.emit('log', 'warn',
              'Events must be within the last 24 hours starting from the next harvest.')
    return
  }

  if (this._oldest_timestamp > event.timestamp) {
    this._oldest_timestamp = event.timestamp
  }

  // Toss it in the queue.
  this._events.push(event)

  // We flush events if they get to the max number.
  if (this._events.length === this.max_events) {
    this.emit('log', 'info', 'Event count hit max, flushing now.')
    this.flush()
  }
}

Pusher.prototype.harvest = function() {
  if (this._events.length > this.min_events) {
    this._harvest()
  } else {
    var day_ago = utils.unix_now()-utils.day_in_secs
    if (this._oldest_timestamp < day_ago) {
      this._harvest()
    }
  }
}

Pusher.prototype._harvest = function () {
  var self = this
  // Reset the events object before we push, just in case.
  var events = this._events
  this._events = []
  this._oldest_timestamp = utils.unix_now()

  // Push the events to Insights
  var request = https.request(this.request_defaults, function (res) {
    if (res.statusCode > 399) {
      self.emit('log', 'warn', 'Error occured while pushing data, got: ' + res.statusCode)
    }
    res.on('data', function (chunk) {
      self.emit('trace', events, chunk)
    })
  })

  request.write(JSON.stringify(events))
  request.end()
}

Pusher.prototype._start_harvester = function () {
  if (this._harvester_enabled) {
    return setInterval(this.harvest.bind(this), this.interval)
  }
}

Pusher.prototype.flush = function() {
  // Stop the harvester, harvest, then start it back up so it will happen
  // this.interval later.
  if (this._harvester) clearInterval(this._harvester)
  this._harvest()
  this.harvester = this._start_harvester()
}


module.exports = Pusher